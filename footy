# -*- coding: utf-8 -*-
"""Football.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Sd4JLLhNIjD3RmqIehJb-AsN9YnDD4X3
"""

import pandas as pd

matches = pd.read_csv("matches.csv", index_col = 0)

matches.head()

matches.shape

no_of_matches_per_season_per_team = 38
no_of_teams = 20
no_of_seasons = 2 #As we have data for two season

total_matches = no_of_matches_per_season_per_team*no_of_teams*no_of_seasons
total_matches

"""This means there's some missing data"""

matches["team"].value_counts()  #Matches per team

"""Since there's a system of relegation, hence the inconsistency in data

**Cleaning of Data**
"""

matches.dtypes

"""Since we can only work with Numeric Data,  """

matches["date"] = pd.to_datetime(matches["date"])

matches["venue_code"] = matches["venue"].astype("category").cat.codes
#0 for away games and 1 for home games

matches["opp_code"] = matches["opponent"].astype("category").cat.codes
matches

matches["hour"] = matches["time"].str.replace(":.+", " ", regex = True).astype("int")

matches["day_code"] = matches["date"].dt.dayofweek

matches["target"] = (matches["result"] == "W").astype("int")
#0 for a loss or draw, 1 for a win

matches

"""**Training the model**"""

from sklearn.ensemble import RandomForestClassifier

rf = RandomForestClassifier(n_estimators=50, min_samples_split=10, random_state=1)

train = matches[matches["date"] < "2022-01-01"]
test = matches[matches["date"] > "2022-01-01"]

predictors = ["venue_code", "opp_code", "hour", "day_code"]

rf.fit(train[predictors], train["target"])

predictions = rf.predict(test[predictors])

from sklearn.metrics import accuracy_score

acc = accuracy_score(test["target"], predictions)
acc

combined = pd.DataFrame(dict(actual=test["target"], predicted=predictions))

pd.crosstab(index=combined["actual"], columns=combined["predicted"])

from sklearn.metrics import precision_score

precision_score(test["target"], predictions)

grouped_matches = matches.groupby("team")
group = grouped_matches.get_group("Chelsea")
group

def rolling_averages(group, cols, new_cols):
  group = group.sort_values("date")
  rolling_stats = group[cols].rolling(3, closed = "left").mean() #Stating that it shouldn't take the current week into consideration
  group[new_cols] = rolling_stats
  group = group.dropna(subset=new_cols)
  return group

cols = ["gf", "ga", "sot", "dist", "fk", "pk", "pkatt"]
new_cols = [f"{c}_rolling" for c in cols]
rolling_averages(group, cols, new_cols)

matches_rolling = matches.groupby("team").apply(lambda x: rolling_averages(x, cols, new_cols))
matches_rolling

matches_rolling = matches_rolling.droplevel("team")

matches_rolling.index = range(matches_rolling.shape[0])

def make_predictons(data, predictors):
  train = data[data["date"] < "2022-01-01"]
  test = data[data["date"] > "2022-01-01"]
  rf.fit(train[predictors], train["target"])
  predictions = rf.predict(test[predictors])
  combined = pd.DataFrame(dict(actual=test["target"], predicted=predictions), index=test.index)
  precision = precision_score(test["target"], predictions)
  return combined, precision

combined, precision = make_predictons(matches_rolling, predictors + new_cols)
precision

combined

combined = combined.merge(matches_rolling[["date", "team", "opponent", "result"]], left_index=True, right_index=True)
combined

class MissingDict(dict):
  __missing__ = lambda self, key: key

map_values = {"Brighton and Hove Albion": "Brighton", "Manchester United": "Manchester Utd", "Newcastle United": "Newcastle Utd", "Tottenham Hotspur": "Tottenham", "West Ham United": "West Ham", "Wolverhampton Wanderers": "Wolves"}
mapping = MissingDict(**map_values)

combined["new_team"] = combined["team"].map(map_values)
combined

merge = combined.merge(combined, left_on=["date", "new_team"], right_on=["date", "opponent"])
merge

acc
